<!-- SIDE BAR -->
<div class="container-panel">
  <div class="main-content">
    <div class="anvil-container" anvil-drop-container=".anvil-container">
    </div>
  </div>

  <!-- Notes Sidebar -->
  <div id="right-sidebar" class="anvil-container" anvil-slot="sidebar">
    <div class="header-sidebar" anvil-slot="Artist_Name_Details_Sidebar">
      <img class="note_svg" src="_/theme/icons/Note.svg" alt="Notes Icon">
      <span>
        Notes for&nbsp<span anvil-if-slot-empty="Artist_Name_Details_Sidebar">Artist Title Here</span>
      </span>
    </div>
    <div class="section-contact-sidebar">
      <div class="contact-table">
        <table> 
          <tr>
            <th>Status</th>
            <td>
              <div class="sidebar-dropdowns" anvil-slot="Status_picker">
                <div anvil-if-slot-empty="Status_picker">Status Picker</div>
              </div>
            </td>
          </tr>
          <tr>
            <th>Priority</th>
            <td>
              <div class="sidebar-dropdowns" anvil-slot="Priority_picker">
                <div anvil-if-slot-empty="Priority_picker">Priority Picker</div>
              </div>
            </td>
          </tr>
          <tr>
            <th>Reminder</th>
            <td>
              <div class="sidebar-dropdowns" anvil-slot="Date_picker">
                <div anvil-if-slot-empty="Date_picker">Date Picker</div>
              </div>
            </td>
          </tr>
        </table>
      </div>
    </div>
    <div class="section-contact-sidebar">
      <div class='contact-title-sidebar'>
        <h3 class="right-sidebar-heading">Contact</h3>
        <div anvil-slot="edit_button_contacts" style="margin: 20px 0 10px 0;">
          <span anvil-if-slot-empty="edit_button_contacts">button</span>
        </div>
      </div>
      <table class="contact-table">
        <tr>
          <th>Name</th>
          <td>
            <div class="artist-name-sidebar contact-table-details" anvil-slot="Text_Box_for_Artist_Name">
              <div anvil-if-slot-empty="Text_Box_for_Artist_Name">Artist Name</div>
            </div>
          </td>
        </tr>
        <tr>
          <th>Email</th>
          <td>
            <div class="artist-name-sidebar contact-table-details" anvil-slot="Text_Box_for_Artist_Email">
              <div anvil-if-slot-empty="Text_Box_for_Artist_Email">Artist Email</div>
          </td>
        </tr>
        <tr>
          <th>Phone</th>
          <td>
            <div class="artist-name-sidebar contact-table-details" anvil-slot="Text_Box_for_Artist_Phone">
              <div anvil-if-slot-empty="Text_Box_for_Artist_Phone">Artist Phone Num</div>
          </td>
        </tr>
      </table>
    </div>
    <div class="description-section-sidebar">
      <div class='contact-title-sidebar'>
        <h3 class="right-sidebar-heading">Description</h3>
        <div anvil-slot="edit_button_decription" style="margin: 20px 0 10px 0;">
          <span anvil-if-slot-empty="edit_button_decription">button</span>
        </div>
      </div>
      <div anvil-slot="descripion-area">
        <div anvil-if-slot-empty="descripion-area">Text Area Goes Here</div>
      </div>
    </div>
    <div class="comments-section-sidebar">
      <h3>Comments</h3>
      <div anvil-slot="comment-area">
        <div anvil-if-slot-empty="comment-area">Text Area Goes Here</div>
      </div>
    </div>
  </div>

  <!-- Agent Sidebar -->
  <div id="agent-sidebar" class="anvil-container" anvil-slot="agent-sidebar">
    <div class="header-sidebar">
      <i class="fas fa-robot" style="font-size: 20px; margin-right: 12px;"></i>
      <span>AI Agent</span>
    </div>
    
    <div class="chat-container">
      <div class="chat-messages" id="chat-messages">
      <!-- Initial welcome message -->
      <div class="message agent">
        <div class="message-time">Just now</div>
        <div class="message-content">
          Hello! I'm your AI assistant. How can I help you today?
        </div>
      </div>

        <!-- User message 
        <div class="message user">
          <div class="message-time">11:46 AM</div>
          <div class="message-content">
            Hi! I'm looking for information about the talent development program.
          </div>
        </div>

        Agent message
        <div class="message agent">
          <div class="message-time">11:46 AM</div>
          <div class="message-content">
            I'd be happy to help! Our talent development program focuses on skill enhancement and career growth. What specific information are you looking for?
          </div>
        </div>

        User message
        <div class="message user">
          <div class="message-time">11:46 AM</div>
          <div class="message-content">
            Give me artists which are less popular than the artist I clicked on.
          </div>
        </div>

        Agent message
        <div class="message agent">
          <div class="message-time">11:46 AM</div>
          <div class="message-content">
            Sure, here are some artists that are less popular than the artist you clicked on.
          </div>
        </div>-->

    </div>
    </div>

    <div class="chat-input-container">
      <textarea id="chat-input" placeholder="Type your message here..." rows="3"></textarea>
      <button id="send-button" aria-label="Send message">
        <img src="_/theme/icons/paper-plane-horizontal.png" alt="Send" class="send-icon">
      </button>
    </div>

  </div>
  
</div>

</div>

<!-- Agent Button -->
<button class="agent-sidebar-button" id="agent-sidebar-button" style="bottom: 20%;">
  <i class="fas fa-robot"></i>
  <br>
  Agent
</button>

<!-- Notes Button -->
<button class="sidebar-button" id="sidebar-button" style="top: 30%;">
  <img class="note_svg_button" src="_/theme/icons/Note.svg" alt="Notes Icon">
  <br>
  Notes
</button>

<!-- FOOTER -->
<div class="footer">
  <div class="footer-slot" anvil-slot="footer-slot">
    <div class="placeholder anvil-designer-only" anvil-if-slot-empty="footer-slot" anvil-drop-here>Drop a FlowPanel or Label or Link Component here</div>
  </div>
</div> 


<script>
/* 1. WebSocketManager Class - Core WebSocket functionality */
// Only define WebSocketManager if it doesn't already exist
(function() {
  'use strict';
  
  if (typeof window.WebSocketManager !== 'undefined') {
    return;  // WebSocket connection manager
  }
  class WebSocketManager {
    constructor() {
      this.socket = null;
      this.sessionId = 'user-' + Math.random().toString(36).substr(2, 9);
      this.chatContainer = document.querySelector('.chat-container');
      this.chatMessages = document.getElementById('chat-messages');
      this.chatInput = document.getElementById('chat-input');
      this.sendButton = document.getElementById('send-button');
      this.lastBotMessage = null;
      this.typingIndicator = null;
      this.messageQueue = [];
      this.isConnected = false;
      this.reconnectAttempts = 0;
      this.maxReconnectAttempts = 5;
      this.reconnectDelay = 1000;
      
      // Debug information
      console.log('[WebSocketManager] Constructor called');
      console.log('[WebSocketManager] Hostname:', window.location.hostname);
      console.log('[WebSocketManager] Protocol:', window.location.protocol);
      
      // For development - always use localhost:8000 for now
      this.wsUrl = `ws://localhost:8000/ws/${this.sessionId}`;
      
      // Log the final WebSocket URL
      console.log('[WebSocketManager] Using WebSocket URL:', this.wsUrl);
      
      // Check if the URL is valid
      try {
        new URL(this.wsUrl);
      } catch (e) {
        console.error('[WebSocketManager] Invalid WebSocket URL:', e);
      }
      
      // Initialize connection
      this.connect();
    }
    
    /* 2. Connection Management */
    async connect() {
      console.log(`[WebSocketManager] === connect() called ===`);
      console.log(`[WebSocketManager] Current connection state:`, this.socket ? this.socket.readyState : 'No socket');
      console.log(`[WebSocketManager] Attempting to connect to: ${this.wsUrl}`);
      
      // First, test the connection
      const canConnect = await this.testConnection();
      if (!canConnect) {
        console.error('[WebSocketManager] Connection test failed, aborting connection attempt');
        
        // Show detailed error message to user
        const errorDetails = `Failed to connect to WebSocket server at ${this.wsUrl}.\n\n` +
          `Possible causes:\n` +
          `1. The WebSocket server is not running\n` +
          `2. The URL is incorrect\n` +
          `3. A firewall is blocking the connection\n` +
          `4. The server is not configured to accept WebSocket connections`;
          
        this.addSystemMessage(errorDetails);
        return;
      }
      
      console.log('[WebSocketManager] Connection test passed, proceeding with connection');
      
      // Close existing connection if any
      if (this.socket) {
        console.log('[WebSocketManager] Closing existing WebSocket connection');
        try {
          this.socket.close();
          console.log('[WebSocketManager] Existing WebSocket connection closed');
        } catch (e) {
          console.warn('[WebSocketManager] Error closing existing socket:', e);
        } finally {
          this.socket = null;
        }
      }
      
      this.isConnected = false;
      
      try {
        console.log('[WebSocketManager] Creating new WebSocket instance');
        this.socket = new WebSocket(this.wsUrl);
        
        console.log('[WebSocketManager] WebSocket created, setting up event handlers');
        
        this.socket.onopen = () => {
          console.log('[WebSocketManager] WebSocket onopen event fired');
          console.log('[WebSocketManager] WebSocket connection opened successfully');
          this.isConnected = true;
          this.reconnectAttempts = 0;
          this.reconnectDelay = 1000;
          this.processMessageQueue();
          
          // Remove any reconnect buttons
          const reconnectBtn = document.getElementById('ws-reconnect-btn');
          if (reconnectBtn) reconnectBtn.remove();
        };
        
        this.socket.onmessage = (event) => {
          console.log('[WebSocketManager] Received message:', event.data);
          this.handleMessage(event);
        };
        
        this.socket.onclose = (event) => {
          console.log(`[WebSocketManager] WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason || 'No reason provided'}`);
          this.isConnected = false;
          this.handleReconnect();
        };
        
        this.socket.onerror = (error) => {
          console.error('[WebSocketManager] WebSocket error event fired:', error);
          console.error('[WebSocketManager] Error event type:', error.type);
          console.error('[WebSocketManager] Error event target readyState:', error.target ? error.target.readyState : 'no target');
          
          this.isConnected = false;
          this.addErrorMessage('Connection error occurred. ' + 
            (error.message || 'Check browser console for details.'));
            
          console.log('[WebSocketManager] Current WebSocket readyState:', this.socket ? this.socket.readyState : 'no socket');
          
          // Log more detailed error information
          if (error && error.target) {
            console.error('[WebSocketManager] WebSocket error details:', {
              url: error.target.url,
              readyState: error.target.readyState,
              bufferedAmount: error.target.bufferedAmount,
              extensions: error.target.extensions,
              protocol: error.target.protocol
            });
          }
        };
        
      } catch (error) {
        console.error('[WebSocketManager] Failed to establish WebSocket connection:', error);
        this.addErrorMessage('Failed to connect to the server');
        this.handleReconnect();
      }
    }
    
    // 2.4. Clean up WebSocket resources
    cleanupSocket() {
      if (!this.socket) return;
      
      try {
        this.socket.onopen = null;
        this.socket.onclose = null;
        this.socket.onerror = null;
        this.socket.onmessage = null;
        this.socket.close();
      } catch (e) {
        console.warn('Error cleaning up socket:', e);
      } finally {
        this.socket = null;
      }
    }
    
    // 2.5. Set up WebSocket event handlers
    setupEventHandlers() {
      if (!this.socket) return;
      
      this.socket.onopen = this.handleOpen.bind(this);
      this.socket.onmessage = this.handleMessage.bind(this);
      this.socket.onclose = this.handleClose.bind(this);
      this.socket.onerror = this.handleError.bind(this);
    }
    
    // 2.6. Handle WebSocket open event
    handleOpen() {
      console.log('[WebSocketManager] WebSocket connected');
      this.isConnected = true;
      this.reconnectAttempts = 0; // Reset reconnect attempts
      
      // Log WebSocket URL for debugging
      console.log(`[WebSocketManager] Connected to: ${this.socket.url}`);
      
      // Process any queued messages
      this.processMessageQueue();
      
      // Notify user
      this.addSystemMessage('Connected to AI Assistant');
    }
    
    // 2.7. Handle WebSocket close event
    handleClose(event) {
      this.isConnected = false;
      this.handleReconnect();
    }
    
    // 2.8. Handle WebSocket error event
    handleError(error) {
      this.isConnected = false;
      this.addErrorMessage('Connection error occurred. ' + 
        (error.message || 'Check browser console for details.'));
      
      if (error && error.target) {
        console.error('WebSocket error details:', {
          url: error.target.url,
          readyState: error.target.readyState
        });
      }
    }
    
    /* 3. Message Handling */
    handleMessage(event) {
      try {
        const message = JSON.parse(event.data);
        console.log('[WebSocketManager] Received message:', message);
        
        if (message.type === 'partial_response') {
          try {
            const content = JSON.parse(message.content);
            if (content.summary) {
              // Only show the summary
              this.updateOrCreateBotMessage(content.summary);
            } else if (content.content) {
              // Fallback to content if summary is not available
              this.updateOrCreateBotMessage(content.content);
            }
          } catch (e) {
            // If parsing fails, show the raw content
            this.updateOrCreateBotMessage(message.content);
          }
        } 
        else if (message.type === 'complete') {
          this.markLastMessageComplete();
          
          // Remove any typing indicator when complete
          this.removeTypingIndicator();
            console.warn('Unknown message type:', message.type);
            this.addSystemMessage(`Received unknown message type: ${message.type}`);
        }
      } catch (error) {
        console.error('Error handling message:', error);
        this.addErrorMessage('Error processing message');
      }
    }
    
    // 3.2. Handle text chunk messages
    handleTextChunk(message) {
      if (message.content) {
        this.updateOrCreateBotMessage(message.content);
        this.scrollToBottom();
      }
    }
    
    // 3.3. Handle error messages
    handleError(message) {
      console.error('[WebSocketManager] Server error:', message);
      const errorMsg = message.content || 'An unknown error occurred';
      this.addErrorMessage(`Error: ${errorMsg}`);
      
      // Log additional error details if available
      if (message.data?.error_type) {
        console.error('Error type:', message.data.error_type);
      }
    }
    
    // 3.4. Handle artist information
    handleArtistInfo(message) {
      console.log('[WebSocketManager] Artist info received:', message);
      
      if (message.data) {
        const artist = message.data;
        const followers = artist.followers ? this.formatFollowers(artist.followers) : 'unknown';
        const popularity = artist.popularity || 'unknown';
        
        this.addSystemMessage(`✅ Found artist: ${artist.name} (${followers} followers, ${popularity} popularity)`);
        
        // Store artist info for future reference
        if (this.lastBotMessage) {
          this.lastBotMessage.artistData = artist;
        }
      } else {
        this.addSystemMessage(message.content || 'Received artist information');
      }
    }
    
    // 3.5. Handle partial response messages (legacy)
    handlePartialResponse(message) {
      if (message.content) {
        try {
          const content = typeof message.content === 'string' ? 
                        JSON.parse(message.content) : message.content;
          
          if (content._type === 'artist_identified') {
            this.handleArtistIdentified(content.data);
          } else if (content._type === 'artist_not_found') {
            this.handleArtistNotFound(content);
          } else if (content.summary) {
            this.updateOrCreateBotMessage(content.summary);
          } else if (content.content) {
            this.updateOrCreateBotMessage(content.content);
          } else {
            this.updateOrCreateBotMessage(JSON.stringify(content));
          }
        } catch (e) {
          console.error('Error processing partial response:', e);
          this.updateOrCreateBotMessage(message.content);
        }
      }
    }
    
    // 3.3. Handle complete message
    handleCompleteMessage() {
      this.markLastMessageComplete();
      this.removeTypingIndicator();
    }
    
    // 3.4. Handle server errors
    handleServerError(message) {
      console.error('Server error:', message.content);
      this.addErrorMessage(message.content || 'An error occurred');
    }
    
    // 3.5. Handle artist identified message
    handleArtistIdentified(artist) {
      const formatFollowers = (numStr) => {
        if (!numStr) return '0';
        const num = typeof numStr === 'string' ? 
                  parseInt(numStr.replace(/,/g, ''), 10) : numStr;
        if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
        if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
        return num.toString();
      };

      const artistElement = document.createElement('a');
      artistElement.href = `artists?artist_id=${encodeURIComponent(artist.artist_id || '')}`;
      artistElement.className = 'message artist';
      artistElement.innerHTML = `
        <div class="artist-image" 
             style="background-image: url('${artist.image_url || 'https://via.placeholder.com/60'}')">
        </div>
        <div class="artist-info">
          <div class="artist-name">${this.escapeHtml(artist.name)}</div>
          <div class="artist-followers">
            ${formatFollowers(artist.followers)} Spotify followers
          </div>
        </div>
      `;
      
      this.chatMessages.appendChild(artistElement);
      this.scrollToBottom();
    }
    
    // 3.6. Handle artist not found message
    handleArtistNotFound(message) {
      this.addSystemMessage(`❌ Artist not found: ${message.query || 'Unknown'}`);
      
      if (message.suggestions?.length > 0) {
        this.addSystemMessage(`Did you mean: ${message.suggestions.join(', ')}?`);
      }
    }
    
    // 3.7. Handle final response message
    handleFinalResponse(message) {
      this.addSystemMessage(message.content);
    }
    
    // 3.8. Handle reconnection with exponential backoff
    handleReconnect() {
      if (this.reconnectAttempts >= this.maxReconnectAttempts) {
        this.addSystemMessage('Unable to reconnect. Please refresh the page to try again.');
        return;
      }
      
      this.reconnectAttempts++;
      const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), 30000);
      
      this.addSystemMessage(`Connection lost. Reconnecting in ${Math.ceil(delay/1000)} seconds...`);
      
      setTimeout(() => {
        console.log(`Reconnect attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
        this.connect();
      }, delay);
    }
    
    // Process any queued messages
    processMessageQueue() {
      while (this.messageQueue.length > 0 && this.isConnected) {
        const message = this.messageQueue.shift();
        this.sendRawMessage(message);
      }
    }
    
    // Send message to the server
    sendMessage(message) {
      console.log('[WebSocketManager] sendMessage() called');
      
      const messageText = message || this.chatInput?.value.trim();
      if (!messageText) {
        console.log('[WebSocketManager] Empty message, ignoring');
        return;
      }
      
      console.log('[WebSocketManager] Adding user message to chat');
      this.addUserMessage(messageText);
      
      // Clear input if we're using the chat input
      if (this.chatInput) {
        this.chatInput.value = '';
        this.chatInput.style.height = 'auto'; // Reset textarea height
      }
      
      this.showTypingIndicator();
      
      // Prepare message
      const messageData = {
        type: 'query',
        content: messageText,
        timestamp: new Date().toISOString()
      };
      
      console.log('[WebSocketManager] Prepared message:', messageData);
      
      // Check WebSocket state
      const socketReady = this.socket && this.socket.readyState === WebSocket.OPEN;
      console.log(`[WebSocketManager] WebSocket state: ${this.socket ? this.socket.readyState : 'null'}, isConnected: ${this.isConnected}, socketReady: ${socketReady}`);
      
      // Send or queue the message
      if (this.isConnected && socketReady) {
        console.log('[WebSocketManager] Sending message via WebSocket');
        this.sendRawMessage(messageData);
      } else {
        console.log('[WebSocketManager] Queueing message, attempting to reconnect');
        this.messageQueue.push(messageData);
        this.addSystemMessage('Message queued. Will send when connection is restored...');
        this.connect(); // Try to reconnect if not connected
      }
    }
    
    // Send raw message to WebSocket
    sendRawMessage(messageData) {
      try {
        console.log('[WebSocketManager] Sending raw message to WebSocket:', messageData);
        const messageString = JSON.stringify(messageData);
        console.log('[WebSocketManager] Stringified message:', messageString);
        
        if (!this.socket) {
          throw new Error('WebSocket is not initialized');
        }
        
        this.socket.send(messageString);
        console.log('[WebSocketManager] Message sent successfully');
      } catch (error) {
        console.error('[WebSocketManager] Error sending raw message:', error);
        this.addErrorMessage('Failed to send message');
        this.handleReconnect();
      }
    }
    
    /* 4. UI Update Methods */
    
    // 4.1. Add user message to chat
    addUserMessage(message) {
      // Create a new message element
      const messageElement = document.createElement('div');
      messageElement.className = 'message user';
      
      // Set message content and time
      messageElement.innerHTML = `
        <div class="message-time">${this.getCurrentTime()}</div>
        <div class="message-content">${this.escapeHtml(message)}</div>
      `;
      
      // Add message to chat and scroll to bottom
      this.chatMessages.appendChild(messageElement);
      this.scrollToBottom();
      
      // Show typing indicator
      this.showTypingIndicator();
    }
    
    // 4.2. Add system message to chat
    addSystemMessage(content) {
      // Create a new message element
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message system';
      
      // Set message content and time
      messageDiv.innerHTML = `
        <div class="message-time">${this.getCurrentTime()}</div>
        <div class="message-content">${this.escapeHtml(content)}</div>
      `;
      
      // Add message to chat and scroll to bottom
      this.chatMessages.appendChild(messageDiv);
      this.scrollToBottom();
    }
    
    // 4.3. Add error message to chat
    addErrorMessage(content) {
      // Create a new message element
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message error';
      
      // Set message content and time
      messageDiv.innerHTML = `
        <div class="message-time">${this.getCurrentTime()}</div>
        <div class="message-content">${this.escapeHtml(content)}</div>
      `;
      
      // Add message to chat and scroll to bottom
      this.chatMessages.appendChild(messageDiv);
      this.scrollToBottom();
    }
    
    // 4.4. Update or create bot message (for streaming)
    updateOrCreateBotMessage(content) {
      // Remove typing indicator
      this.removeTypingIndicator();
      
      // Create a new bot message element if needed
      if (!this.lastBotMessage) {
        this.lastBotMessage = document.createElement('div');
        this.lastBotMessage.className = 'message agent';
        this.lastBotMessage.innerHTML = `
          <div class="message-time">${this.getCurrentTime()}</div>
          <div class="message-content"></div>
        `;
        this.chatMessages.appendChild(this.lastBotMessage);
      }
      
      // Update message content
      const contentDiv = this.lastBotMessage.querySelector('.message-content');
      contentDiv.textContent = content;
      
      // Scroll to bottom
      this.scrollToBottom();
    }
    
    // 4.5. Alias for backward compatibility
    updateOrAddBotMessage(content) {
      this.updateOrCreateBotMessage(content);
    }
    
    // 4.6. Mark last bot message as complete
    markLastMessageComplete() {
      this.lastBotMessage = null;
      this.removeTypingIndicator();
    }
    
    // 4.7. Show typing indicator
    showTypingIndicator() {
      // Remove existing typing indicator
      this.removeTypingIndicator();
      
      // Create a new typing indicator element
      this.typingIndicator = document.createElement('div');
      this.typingIndicator.className = 'waiting-indicator';
      this.typingIndicator.textContent = 'AIDAR is thinking';
      
      // Add typing indicator to chat container
      this.chatContainer.appendChild(this.typingIndicator);
      
      // Scroll to bottom
      this.scrollToBottom();
    }
    
    // 4.8. Remove typing indicator
    removeTypingIndicator() {
      if (this.typingIndicator) {
        this.typingIndicator.remove();
        this.typingIndicator = null;
      }
    }
    
    // 4.9. Process queued messages
    processMessageQueue() {
      // Check if WebSocket is connected
      if (!this.isConnected) return;
      
      // Process all queued messages
      while (this.messageQueue.length > 0) {
        const message = this.messageQueue.shift();
        this.sendMessageInternal(message);
      }
    }
    
    // 4.10. Internal method to send a message
    sendMessageInternal(message) {
      // Check if WebSocket is connected and ready
      if (!this.isConnected || !this.socket || this.socket.readyState !== WebSocket.OPEN) {
        // Queue message and reconnect if not connected
        this.messageQueue.push(message);
        this.handleReconnect();
        return false;
      }
      
      try {
        // Send message via WebSocket
        this.socket.send(JSON.stringify(message));
        return true;
      } catch (error) {
        // Handle send error
        console.error('Error sending message:', error);
        this.addErrorMessage('Failed to send message');
        return false;
      }
    }
    
    // 4.11. Send user message
    sendMessage() {
      // Get user input message
      const message = this.chatInput.value.trim();
      
      // Check if message is empty
      if (!message) return;
      
      // Add user message to chat
      this.addUserMessage(message);
      
      // Clear input field and dispatch input event
      this.chatInput.value = '';
      this.chatInput.dispatchEvent(new Event('input'));
      
      // Send message internally
      this.sendMessageInternal({
        type: 'user_message',
        content: message,
        timestamp: new Date().toISOString()
      });
    }
    
    // 4.12. Scroll chat to bottom
    scrollToBottom() {
      // Check if chat messages element exists
      if (this.chatMessages) {
        // Scroll to bottom
        this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
      }
    }
    
    // 4.13. Get current time in HH:MM format
    getCurrentTime() {
      // Get current date and time
      const now = new Date();
      
      // Format time as HH:MM
      return now.getHours().toString().padStart(2, '0') + ':' + 
             now.getMinutes().toString().padStart(2, '0');
    }
    
    // 4.14. Escape HTML to prevent XSS
    escapeHtml(unsafe) {
      // Check if input is empty
      if (!unsafe) return '';
      
      // Escape HTML characters
      return unsafe
        .toString()
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }
  }
  
  // Expose WebSocketManager to window
  window.WebSocketManager = WebSocketManager;
  
  // Initialize WebSocket manager
  function initializeWebSocketManager() {
    console.log('[WebSocketManager] Initializing WebSocket manager');
    
    // Only initialize once
    if (window.wsManager) {
      console.log('[WebSocketManager] WebSocket manager already initialized');
      return window.wsManager;
    }
    
    // Initialize WebSocket manager and expose it globally
    try {
      window.wsManager = new WebSocketManager();
      console.log('[WebSocketManager] WebSocket manager initialized and exposed as window.wsManager');
      
      // Set up event listeners
      const sendButton = document.getElementById('send-button');
      const chatInput = document.getElementById('chat-input');
      
      if (!sendButton || !chatInput) {
        console.error('[WebSocketManager] Critical Error: Could not find required DOM elements');
        return window.wsManager;
      }
      
      console.log('[WebSocketManager] Found required DOM elements');
      
      // Auto-resize textarea
      chatInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
        
        // Update send button state
        const hasText = this.value.trim() !== '';
        sendButton.disabled = !hasText;
        console.log(`[WebSocketManager] Input changed, hasText: ${hasText}`);
      });
      
      // Send message on button click
      sendButton.addEventListener('click', () => {
        const message = chatInput.value.trim();
        if (message) {
          window.wsManager.sendMessage(message);
        }
      });
      
      // Send message on Enter key (but allow Shift+Enter for new lines)
      chatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          const message = chatInput.value.trim();
          if (message) {
            window.wsManager.sendMessage(message);
          }
        }
      });
      
      // Initial button state
      sendButton.disabled = true;
      
      // Handle window unload
      window.addEventListener('beforeunload', () => {
        console.log('[WebSocketManager] Window unloading, cleaning up WebSocket');
        if (window.wsManager && window.wsManager.socket) {
          window.wsManager.socket.close(1000, 'Window closing');
        }
      });
      
      // Add a button to manually reconnect
      const addReconnectButton = () => {
        const existingBtn = document.getElementById('ws-reconnect-btn');
        if (existingBtn) return;
        
        const btn = document.createElement('button');
        btn.id = 'ws-reconnect-btn';
        btn.textContent = 'Reconnect to AI Assistant';
        btn.style.position = 'fixed';
        btn.style.bottom = '20px';
        btn.style.right = '20px';
        btn.style.zIndex = '1000';
        btn.style.padding = '10px 20px';
        btn.style.backgroundColor = '#e95f30';
        btn.style.color = 'white';
        btn.style.border = 'none';
        btn.style.borderRadius = '5px';
        btn.style.cursor = 'pointer';
        btn.onclick = () => {
          console.log('[WebSocketManager] Manual reconnect requested');
          if (window.wsManager) {
            window.wsManager.connect();
          } else {
            window.wsManager = new WebSocketManager();
          }
          btn.remove();
        };
        document.body.appendChild(btn);
      };
      
      // Show reconnect button on connection issues
      const checkConnection = setInterval(() => {
        if (window.wsManager && !window.wsManager.isConnected) {
          console.log('[WebSocketManager] Connection check: Not connected, showing reconnect button');
          addReconnectButton();
          clearInterval(checkConnection);
        }
      }, 5000);
      
      console.log('[WebSocketManager] WebSocket manager initialization complete');
      return window.wsManager;
      
    } catch (error) {
      console.error('[WebSocketManager] Failed to initialize WebSocket manager:', error);
      
      // Show error to user
      const errorMsg = document.createElement('div');
      errorMsg.style.position = 'fixed';
      errorMsg.style.bottom = '20px';
      errorMsg.style.right = '20px';
      errorMsg.style.backgroundColor = '#ff4444';
      errorMsg.style.color = 'white';
      errorMsg.style.padding = '10px 20px';
      errorMsg.style.borderRadius = '5px';
      errorMsg.style.zIndex = '1000';
      errorMsg.textContent = 'Failed to connect to AI Assistant. Please refresh the page.';
      document.body.appendChild(errorMsg);
      
      return null;
    }
  }
  
  // Initialize when DOM is loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeWebSocketManager);
  } else {
    initializeWebSocketManager();
  }

  // Notes Sidebar
  if(typeof sidebar === 'undefined') {
    const sidebar = document.getElementById('right-sidebar');
    const button = document.getElementById('sidebar-button');
    const mainContent = document.querySelector('.main-content-move');
    const content = document.querySelector('.main-content');
    const agentSidebar = document.getElementById('agent-sidebar');
    const agentButton = document.getElementById('agent-sidebar-button');

    function updateMargins() {
      const notesOpen = sidebar.classList.contains('open');
      const agentOpen = agentSidebar && agentSidebar.classList.contains('open');

      // Calculate total margin based on open sidebars
      let totalMargin = 0;
      if (notesOpen && agentOpen) {
        totalMargin = 800; // Both sidebars open
      } else if (notesOpen || agentOpen) {
        totalMargin = 400; // One sidebar open
      } // else 0, both closed

      // Apply the new margin with smooth transition
      if (mainContent) mainContent.style.marginRight = totalMargin + 'px';
      if (content) content.style.marginRight = totalMargin + 'px';

      // Update button positions
      if (button) button.style.right = (notesOpen ? totalMargin : 0) + 'px';
      if (agentButton) agentButton.style.right = (agentOpen ? totalMargin : 0) + 'px';
    }

    if (sidebar && button && content && mainContent) {
      button.addEventListener('click', function () {
        sidebar.classList.toggle('open');
        button.classList.toggle('open');
        updateMargins();
      });
    } else {
      console.error("Required elements not found");
    }
  }

  (function() {
    let displays = document.querySelectorAll('.note-display');
    const transitionDuration = 900;

    displays.forEach(display => {
      let note = parseFloat(display.dataset.note);
      let [int, dec] = display.dataset.note.split('.');
      [int, dec] = [Number(int), Number(dec)];

      strokeTransition(display, note);

      increaseNumber(display, int, 'int');
    });

    function increaseNumber(display, number, className) {
      let element = display.querySelector(`.percent__${className}`),
        decPoint = className === 'int' ? '%' : '',
        interval = 900 / number,
        counter = 0;

      let increaseInterval = setInterval(() => {
        if (counter === number) { window.clearInterval(increaseInterval); }

        element.textContent = counter + decPoint;
        counter++;
      }, interval);
    }

    function strokeTransition(display, note) {
      let progress = display.querySelector('.circle__progress--fill');
      let radius = progress.r.baseVal.value;
      let circumference = 2 * Math.PI * radius;
      let offset = circumference * (100 - note) / 100;

      progress.style.setProperty('--initialStroke', circumference);
      progress.style.setProperty('--transitionDuration', `${transitionDuration}ms`);

      setTimeout(() => progress.style.strokeDashoffset = offset, 1000);
    }
  })();

  // Agent Sidebar
  if (typeof agentSidebar === 'undefined') {
    const agentSidebar = document.getElementById('agent-sidebar');
    const agentButton = document.getElementById('agent-sidebar-button');
    const notesButton = document.getElementById('sidebar-button');
    const chatInput = document.getElementById('chat-input');
    const sendButton = document.getElementById('send-button');
    const chatMessages = document.getElementById('chat-messages');
    const sidebar = document.getElementById('right-sidebar');
    const mainContent = document.querySelector('.main-content-move');
    const content = document.querySelector('.main-content');

    function updateAgentMargins() {
      const agentOpen = agentSidebar.classList.contains('open');
      const notesOpen = sidebar && sidebar.classList.contains('open');

      // Calculate total margin based on open sidebars
      let totalMargin = 0;
      if (notesOpen && agentOpen) {
        totalMargin = 800; // Both sidebars open
      } else if (notesOpen || agentOpen) {
        totalMargin = 400; // One sidebar open
      } // else 0, both closed

      // Apply the new margin with smooth transition
      if (mainContent) mainContent.style.marginRight = totalMargin + 'px';
      if (content) content.style.marginRight = totalMargin + 'px';

      // Update button positions
      if (notesButton) notesButton.style.right = (notesOpen ? totalMargin : 0) + 'px';
      if (agentButton) agentButton.style.right = (agentOpen ? totalMargin : 0) + 'px';
    }

    if (agentButton && agentSidebar && notesButton && chatInput && sendButton && chatMessages) {
      // Position notes button below agent button
      function positionAgentButton() {
        const agentRect = agentButton.getBoundingClientRect();
        notesButton.style.top = `${agentRect.bottom + 20}px`;
      }

      // Initial positioning
      positionAgentButton();

      // Re-position on window resize
      window.addEventListener('resize', positionAgentButton);

      // Toggle sidebar
      agentButton.addEventListener('click', function() {
        agentSidebar.classList.toggle('open');
        agentButton.classList.toggle('open');
        updateAgentMargins();
      });

      // Also update margins when notes sidebar is toggled
      if (sidebar) {
        const observer = new MutationObserver(updateAgentMargins);
        observer.observe(sidebar, { attributes: true, attributeFilter: ['class'] });
      }

      // Auto-scroll to bottom of chat with smooth animation
      function scrollToBottom() {
        if (chatMessages) {
          chatMessages.scrollTo({
            top: chatMessages.scrollHeight,
            behavior: 'smooth'
          });
        }
      }

      // Initial scroll to bottom
      scrollToBottom();

      // Scroll to bottom when content changes
      if (chatMessages) {
        let isScrolling = false;
        const scrollObserver = new MutationObserver(() => {
          if (!isScrolling) {
            isScrolling = true;
            // Small delay to ensure DOM is updated
            requestAnimationFrame(() => {
              scrollToBottom();
              isScrolling = false;
            });
          }
        });

        // Observe chat messages for changes
        scrollObserver.observe(chatMessages, { childList: true, subtree: true });
      }

      // Format time
      function getCurrentTime() {
        const now = new Date();
        return now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }

      // Add a new message to the chat
      function addMessage(content, isUser) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${isUser ? 'user' : 'agent'}`;

        const timeDiv = document.createElement('div');
        timeDiv.className = 'message-time';
        timeDiv.textContent = getCurrentTime();

        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        contentDiv.textContent = content;

        messageDiv.appendChild(timeDiv);
        messageDiv.appendChild(contentDiv);
        chatMessages.appendChild(messageDiv);

        scrollToBottom();
      }

      // Safe function to get or initialize WebSocket manager
      function getWebSocketManager() {
        if (!window.wsManager) {
          console.log('[AgentSidebar] Initializing WebSocket manager from agent sidebar');
          initializeWebSocketManager();
        }
        return window.wsManager;
      }

      // Event listeners for the agent sidebar
      sendButton.addEventListener('click', (e) => {
        console.log('[AgentSidebar] Send button clicked');
        e.preventDefault();
        const message = chatInput.value.trim();
        console.log('[AgentSidebar] Message to send:', message);
        
        if (message) {
          try {
            console.log('[AgentSidebar] Getting WebSocket manager');
            const manager = getWebSocketManager();
            console.log('[AgentSidebar] WebSocket manager:', manager ? 'found' : 'not found');
            
            if (manager) {
              console.log('[AgentSidebar] Adding message to chat UI');
              addMessage(message, true);  // true for user message
              
              // Clear input field
              chatInput.value = '';
              updateSendButtonState();
              
              console.log('[AgentSidebar] Showing typing indicator');
              manager.showTypingIndicator();
              
              console.log('[AgentSidebar] Sending message via WebSocket');
              manager.sendMessage(message);
            } else {
              console.error('[AgentSidebar] Failed to get WebSocket manager');
            }
          } catch (error) {
            console.error('[AgentSidebar] Error sending message:', error);
          }
        } else {
          console.log('[AgentSidebar] No message to send');
        }
      });

      // Handle input changes
      function updateSendButtonState() {
        const hasText = chatInput.value.trim() !== '';
        sendButton.disabled = !hasText;
        sendButton.classList.toggle('has-text', hasText);
      }

      chatInput.addEventListener('input', updateSendButtonState);

      // Handle Enter key to send message
      chatInput.addEventListener('keypress', function(e) {
        console.log('[AgentSidebar] Key pressed:', e.key);
        
        if (e.key === 'Enter' && !e.shiftKey) {
          console.log('[AgentSidebar] Enter key detected (without shift)');
          e.preventDefault();
          
          const message = chatInput.value.trim();
          console.log('[AgentSidebar] Message to send (Enter key):', message);
          
          if (message) {
            try {
              console.log('[AgentSidebar] Getting WebSocket manager (Enter key)');
              const manager = getWebSocketManager();
              console.log('[AgentSidebar] WebSocket manager (Enter key):', manager ? 'found' : 'not found');
              
              if (manager) {
                console.log('[AgentSidebar] Adding message to chat UI (Enter key)');
                addMessage(message, true);  // true for user message
                
                // Clear input field
                chatInput.value = '';
                updateSendButtonState();
                
                console.log('[AgentSidebar] Showing typing indicator (Enter key)');
                manager.showTypingIndicator();
                
                console.log('[AgentSidebar] Sending message via WebSocket (Enter key)');
                manager.sendMessage(message);
              } else {
                console.error('[AgentSidebar] Failed to get WebSocket manager (Enter key)');
              }
            } catch (error) {
              console.error('[AgentSidebar] Error sending message (Enter key):', error);
            }
          } else {
            console.log('[AgentSidebar] No message to send (Enter key)');
          }
        }
      });

      // Initial states
      updateSendButtonState();
      setTimeout(scrollToBottom, 0);

      // Handle window resize to maintain scroll position
      let resizeTimer;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(scrollToBottom, 100);
      });

      // Clean up on unload
      window.addEventListener('beforeunload', () => {
        scrollObserver.disconnect();
        window.removeEventListener('resize', scrollToBottom);
      });
    }
  }
  
  // Close the IIFE that wraps the agent sidebar code
  })();

  // Debug: Test WebSocket manager functionality
  function testWebSocketManager() {
    console.log('[DEBUG] Testing WebSocket manager...');
    
    // Check if manager exists
    const manager = window.wsManager;
    console.log('[DEBUG] WebSocket manager exists:', !!manager);
    
    if (manager) {
      console.log('[DEBUG] WebSocket manager properties:', {
        isConnected: manager.isConnected,
        socket: manager.socket ? 'exists' : 'null',
        socketState: manager.socket ? manager.socket.readyState : 'N/A'
      });
      
      // Test if methods exist
      console.log('[DEBUG] Method check - sendMessage:', typeof manager.sendMessage === 'function' ? 'exists' : 'missing');
      console.log('[DEBUG] Method check - showTypingIndicator:', typeof manager.showTypingIndicator === 'function' ? 'exists' : 'missing');
    }
  }

  // Debug: Direct event listener for send button
  document.addEventListener('DOMContentLoaded', () => {
    console.log('[DEBUG] DOM fully loaded');
    
    // Run WebSocket manager test
    testWebSocketManager();
    
    // Add debug click handler
    const debugSendButton = document.getElementById('send-button');
    if (debugSendButton) {
      debugSendButton.addEventListener('click', (e) => {
        console.log('[DEBUG] Direct click event on send button');
        console.log('Button element:', debugSendButton);
        console.log('Input value:', document.getElementById('chat-input')?.value);
        
        // Test WebSocket manager on click
        testWebSocketManager();
      });
      console.log('[DEBUG] Added debug click listener to send button');
    } else {
      console.error('[DEBUG] Could not find send button');
    }
  });
</script>
