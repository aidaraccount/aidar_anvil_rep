<!-- SIDE BAR -->
<div class="container-panel">
  <div class="main-content">
    <div class="anvil-container" anvil-drop-container=".anvil-container">
    </div>
  </div>

  <!-- Notes Sidebar -->
  <div id="right-sidebar" class="anvil-container" anvil-slot="sidebar">
    <div class="header-sidebar" anvil-slot="Artist_Name_Details_Sidebar">
      <img class="note_svg" src="_/theme/icons/Note.svg" alt="Notes Icon">
      <span>
        Notes for&nbsp<span anvil-if-slot-empty="Artist_Name_Details_Sidebar">Artist Title Here</span>
      </span>
    </div>
    <div class="section-contact-sidebar">
      <div class="contact-table">
        <table> 
          <tr>
            <th>Status</th>
            <td>
              <div class="sidebar-dropdowns" anvil-slot="Status_picker">
                <div anvil-if-slot-empty="Status_picker">Status Picker</div>
              </div>
            </td>
          </tr>
          <tr>
            <th>Priority</th>
            <td>
              <div class="sidebar-dropdowns" anvil-slot="Priority_picker">
                <div anvil-if-slot-empty="Priority_picker">Priority Picker</div>
              </div>
            </td>
          </tr>
          <tr>
            <th>Reminder</th>
            <td>
              <div class="sidebar-dropdowns" anvil-slot="Date_picker">
                <div anvil-if-slot-empty="Date_picker">Date Picker</div>
              </div>
            </td>
          </tr>
        </table>
      </div>
    </div>
    <div class="section-contact-sidebar">
      <div class='contact-title-sidebar'>
        <h3 class="right-sidebar-heading">Contact</h3>
        <div anvil-slot="edit_button_contacts" style="margin: 20px 0 10px 0;">
          <span anvil-if-slot-empty="edit_button_contacts">button</span>
        </div>
      </div>
      <table class="contact-table">
        <tr>
          <th>Name</th>
          <td>
            <div class="artist-name-sidebar contact-table-details" anvil-slot="Text_Box_for_Artist_Name">
              <div anvil-if-slot-empty="Text_Box_for_Artist_Name">Artist Name</div>
            </div>
          </td>
        </tr>
        <tr>
          <th>Email</th>
          <td>
            <div class="artist-name-sidebar contact-table-details" anvil-slot="Text_Box_for_Artist_Email">
              <div anvil-if-slot-empty="Text_Box_for_Artist_Email">Artist Email</div>
          </td>
        </tr>
        <tr>
          <th>Phone</th>
          <td>
            <div class="artist-name-sidebar contact-table-details" anvil-slot="Text_Box_for_Artist_Phone">
              <div anvil-if-slot-empty="Text_Box_for_Artist_Phone">Artist Phone Num</div>
          </td>
        </tr>
      </table>
    </div>
    <div class="description-section-sidebar">
      <div class='contact-title-sidebar'>
        <h3 class="right-sidebar-heading">Description</h3>
        <div anvil-slot="edit_button_decription" style="margin: 20px 0 10px 0;">
          <span anvil-if-slot-empty="edit_button_decription">button</span>
        </div>
      </div>
      <div anvil-slot="descripion-area">
        <div anvil-if-slot-empty="descripion-area">Text Area Goes Here</div>
      </div>
    </div>
    <div class="comments-section-sidebar">
      <h3>Comments</h3>
      <div anvil-slot="comment-area">
        <div anvil-if-slot-empty="comment-area">Text Area Goes Here</div>
      </div>
    </div>
  </div>

  <!-- Agent Sidebar -->
  <div id="agent-sidebar" class="anvil-container" anvil-slot="agent-sidebar">
    <div class="header-sidebar">
      <i class="fas fa-robot" style="font-size: 20px; margin-right: 12px;"></i>
      <span>Scouting AI Agent</span>
    </div>
    
    <div class="chat-container">
      <div class="chat-messages" id="chat-messages">
      <!-- Initial welcome message -->
      <div class="message agent">
        <div class="message-time">Just now</div>
        <div class="message-content">
          Hello! I'm your Scouting AI assistant. What kind of artist are we looking for today?
        </div>
      </div>

        <!-- User message 
        <div class="message user">
          <div class="message-time">11:46 AM</div>
          <div class="message-content">
            Hi! I'm looking for information about the talent development program.
          </div>
        </div>

        Agent message
        <div class="message agent">
          <div class="message-time">11:46 AM</div>
          <div class="message-content">
            Sure, here are some artists that are less popular than the artist you clicked on.
          </div>
        </div>-->

    </div>
    </div>

    <div class="chat-input-container">
      <textarea id="chat-input" placeholder="Type your message here..." rows="3"></textarea>
      <button id="send-button" aria-label="Send message">
        <img src="_/theme/icons/paper-plane-horizontal.png" alt="Send" class="send-icon">
      </button>
    </div>

  </div>
  
</div>

</div>

<!-- Agent Button -->
<button class="agent-sidebar-button" id="agent-sidebar-button" style="bottom: 20%;">
  <i class="fas fa-robot"></i>
  <br>
  Agent
</button>

<!-- Notes Button -->
<button class="sidebar-button" id="sidebar-button" style="top: 30%;">
  <img class="note_svg_button" src="_/theme/icons/Note.svg" alt="Notes Icon">
  <br>
  Notes
</button>

<!-- FOOTER -->
<div class="footer">
  <div class="footer-slot" anvil-slot="footer-slot">
    <div class="placeholder anvil-designer-only" anvil-if-slot-empty="footer-slot" anvil-drop-here>Drop a FlowPanel or Label or Link Component here</div>
  </div>
</div> 


<script>

  console.log('[WebSocketManager] model_id', sessionStorage.getItem('model_id'));

  // Store the original WebSocketManager if it exists
  if (!window._originalWebSocketManager) {
    window._originalWebSocketManager = window.WebSocketManager;
  }
  
  // Only declare WebSocketManager if it doesn't already exist
  if (typeof window._originalWebSocketManager === 'undefined') {
    window.WebSocketManager = class WebSocketManager {
      // 1. Initialization
      constructor() {
        this.initializeState();
        this.initializeDomReferences();
        this.initializeWebSocket();
      }
      
      initializeState() {
        // Connection state
        this.isConnected = false;
        this.isConnecting = false;
        this.isUpdatingModelId = false;
        this.wasConnectedBeforeError = false;
        
        // Reconnection state
        this.reconnectTimeout = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000;
        
        // Session state
        this.currentModelId = sessionStorage.getItem('model_id');
        this.sessionId = 'user-' + (this.currentModelId || Math.random().toString(36).substr(2, 9));
        this.wsUrl = `ws://localhost:8000/ws/${this.sessionId}`;
        
        // Message state
        this.messageQueue = [];
        this.lastBotMessage = null;
        this.typingIndicator = null;
      }
      
      initializeDomReferences() {
        // UI Elements
        this.chatContainer = document.querySelector('.chat-container');
        this.chatMessages = document.getElementById('chat-messages');
        this.chatInput = document.getElementById('chat-input');
        this.sendButton = document.getElementById('send-button');
        
        // Bind methods
        this.sendMessage = this.sendMessage.bind(this);
        
        // Validate WebSocket URL
        try {
          new URL(this.wsUrl);
        } catch (e) {
          console.error('Invalid WebSocket URL:', e);
        }
      }
      
      initializeWebSocket() {
        this.connect();
      }
      
      // 2. Connection Management
      // 2.1 Clean up existing socket
      cleanupExistingSocket() {
        if (!this.socket) return;
        
        try {
          const oldSocket = this.socket;
          oldSocket.onclose = null;
          oldSocket.close();
        } catch (e) {
          console.error('Error closing existing socket:', e);
        } finally {
          this.socket = null;
        }
      }
      
      // 2.2 Setup WebSocket event handlers
      setupSocketEventHandlers() {
        if (!this.socket) return;
        
        this.socket.onopen = this.handleSocketOpen.bind(this);
        this.socket.onmessage = this.handleSocketMessage.bind(this);
        this.socket.onclose = this.handleSocketClose.bind(this);
        this.socket.onerror = this.handleSocketError.bind(this);
      }
      
      // 2.3 Handle WebSocket events
      handleSocketOpen() {
        this.isConnected = true;
        this.isConnecting = false;
        this.wasConnectedBeforeError = true;
        this.reconnectAttempts = 0;
        
        this.processMessageQueue();
        
        if (this.wasConnectedBeforeError) {
          this.addSystemMessage('Connection re-established');
        }
      }
      
      handleSocketMessage(event) {
        try {
          this.handleMessage(JSON.parse(event.data));
        } catch (error) {
          console.error('Error handling message:', error);
        }
      }
      
      handleSocketClose(event) {
        this.isConnected = false;
        this.isConnecting = false;
        
        if (this.wasConnectedBeforeError && !this.reconnectTimeout) {
          this.attemptReconnect();
        }
      }
      
      handleSocketError(error) {
        console.error('WebSocket error:', error);
        this.wasConnectedBeforeError = this.isConnected;
        this.isConnected = false;
      }
      
      // 2.4 Handle connection errors
      handleConnectionError(error) {
        console.error('Failed to establish WebSocket connection:', error);
        this.addErrorMessage('Failed to connect to the server');
        this.attemptReconnect();
      }
      
      // 2.5 Attempt to reconnect with exponential backoff
      attemptReconnect() {
        // Don't attempt to reconnect if we're in the middle of a model ID update
        if (this.isUpdatingModelId) {
          console.log('[WebSocketManager] Skipping reconnect attempt during model ID update');
          return;
        }
        
        if (this.reconnectTimeout) {
          clearTimeout(this.reconnectTimeout);
        }
        
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
          console.log('[WebSocketManager] Max reconnection attempts reached, giving up');
          this.addSystemMessage('Connection lost. Please refresh the page to try again.');
          return;
        }
        
        const delay = Math.min(
          this.reconnectDelay * Math.pow(2, this.reconnectAttempts),
          30000 // Max 30 seconds
        );
        
        console.log(`[WebSocketManager] Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);
        
        this.reconnectAttempts++;
        
        this.reconnectTimeout = setTimeout(() => {
          if (!this.isConnected && !this.isUpdatingModelId) {
            console.log('[WebSocketManager] Reconnecting...');
            this.connect();
          } else {
            console.log('[WebSocketManager] Skipping reconnect - already connected or updating model ID');
          }
        }, delay);
      }
      
      // 2.6 Main connect method
      connect() {
        // If already connected and socket is open, process queue
        if (this.isConnected && this.socket?.readyState === WebSocket.OPEN) {
          this.processMessageQueue();
          return;
        }
        
        // If already connecting, wait for the connection
        if (this.isConnecting) {
          return;
        }
        
        // Handle existing socket states
        if (this.socket) {
          const state = this.socket.readyState;
          if (state === WebSocket.CONNECTING) return;
          if (state === WebSocket.OPEN) {
            this.isConnected = true;
            this.isConnecting = false;
            this.processMessageQueue();
            return;
          }
        }
        
        this.isConnecting = true;
        this.cleanupExistingSocket();
        
        try {
          // Create new WebSocket connection
          this.socket = new WebSocket(this.wsUrl);
          this.setupSocketEventHandlers();
        } catch (error) {
          this.handleConnectionError(error);
        }
      }
      
      
      /* 3. Message Handling */
      // Handle incoming WebSocket messages
      handleMessage(event) {
        try {
          const message = JSON.parse(event.data);
          console.log('[WebSocketManager] Received message:', message);

          switch (message.type) {
            case 'text_chunk':
              this.handleTextChunk(message);
              break;
              
            case 'error':
              this.handleError(message);
              break;
              
            case 'artist_info':
              this.handleArtistInfo(message);
              break;

            case 'artist_reference':
              this.handleArtistReference(message);
              break;
              
            case 'complete':
              this.handleCompleteMessage();
              break;
              
            default:
              console.warn('[WebSocketManager] Unknown message type:', message.type);
              this.addSystemMessage(`Received unknown message type: ${message.type}`);
          }
        } catch (error) {
          console.error('[WebSocketManager] Error handling message:', error);
          this.addErrorMessage('Error processing message');
        }
      }

      // Handle text chunk messages
      handleTextChunk(message) {
        if (message.content) {
          this.updateOrCreateBotMessage(message.content);
          this.scrollToBottom();
        }
      }

      // Handle error messages
      handleError(message) {
        console.error('[WebSocketManager] Server error:', message.content);
        const errorType = message.data?.error_type ? ` (${message.data.error_type})` : '';
        this.addErrorMessage(`Error${errorType}: ${message.content}`);
      }

      // Handle artist information
      handleArtistInfo(message) {
        console.log('[WebSocketManager] Artist info received:', message);
        
        if (message.data) {
          const artist = message.data;
          const artistId = artist.artist_id || '';
          const imageUrl = artist.image_url || (artist.images?.[0]?.url) || 'https://via.placeholder.com/40';
          const formatFollowers = (numStr) => {
            const num = typeof numStr === 'string' ? parseInt(numStr.replace(/[^0-9]/g, '')) : numStr || 0;
            if (num >= 1000000) {
              return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
            }
            if (num >= 1000) {
              return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
            }
            return num.toString();
          };
          const followers = formatFollowers(artist.followers);
          
          // Create artist message element with artist class
          const messageDiv = document.createElement('a');
          messageDiv.href = `#agent_artists?artist_id=${encodeURIComponent(artistId)}`;
          messageDiv.className = 'message artist';
          
          messageDiv.innerHTML = `
            <div class="artist-image" style="background-image: url('${this.escapeHtml(imageUrl)}')"></div>
            <div class="artist-info">
              <div class="artist-name">${this.escapeHtml(artist.name)}</div>
              <div class="artist-followers">${followers} Spotify followers</div>
            </div>
          `;
          
          this.chatMessages.appendChild(messageDiv);
          this.scrollToBottom();
        } else {
          this.addSystemMessage(message.content || 'Received artist information');
        }
      }

      // Handle artist information
      handleArtistReference(message) {
        console.log('[WebSocketManager] Artist reference received:', message);

        if (message.data) {
          const artist = message.data;
          const artistId = artist.artist_id || '';
          const imageUrl = artist.image_url || (artist.images?.[0]?.url) || 'https://via.placeholder.com/40';
          const formatFollowers = (numStr) => {
            const num = typeof numStr === 'string' ? parseInt(numStr.replace(/[^0-9]/g, '')) : numStr || 0;
            if (num >= 1000000) {
              return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
            }
            if (num >= 1000) {
              return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
            }
            return num.toString();
          };
          const followers = formatFollowers(artist.followers);

          // Create artist message element with artist class
          const messageDiv = document.createElement('a');
          messageDiv.href = `#agent_artists?artist_id=${encodeURIComponent(artistId)}`;
          messageDiv.className = 'message artist';

          messageDiv.innerHTML = `
            <div class="artist-image" style="background-image: url('${this.escapeHtml(imageUrl)}')"></div>
            <div class="artist-info">
              <div class="artist-name">${this.escapeHtml(artist.name)}</div>
              <div class="artist-followers">${followers} Spotify followers</div>
            </div>
            <div class="artist-action">NEW<br>REF</div>
          `;

          this.chatMessages.appendChild(messageDiv);
          this.scrollToBottom();
        } else {
          this.addSystemMessage(message.content || 'Received reference artist');
        }
      }
      
      // Handle complete message from server
      handleCompleteMessage() {
        console.log('[WebSocketManager] Received complete message');
        this.markLastMessageComplete();
        this.removeTypingIndicator();
      }

      // HELPER FUNCTIONS
      // Helper to format followers count
      formatFollowers(count) {
        if (count >= 1000000) {
          return (count / 1000000).toFixed(1) + 'M';
        }
        if (count >= 1000) {
          return (count / 1000).toFixed(1) + 'K';
        }
        return count.toString();
      }
      




      // 3. Message Handling
      sendMessage() {
        const message = this.chatInput?.value?.trim();
        if (!message) return;
        
        // Update UI
        this.addUserMessage(message);
        this.chatInput.value = '';
        this.chatInput.style.height = 'auto';
        this.showTypingIndicator();
        
        // Prepare and send message
        this.queueOrSendMessage({
          type: 'query',
          content: message,
          timestamp: new Date().toISOString()
        });
      }
      
      // 3.1 Queue or send message based on connection state
      queueOrSendMessage(messageData) {
        try {
          if (this.isConnected && this.socket?.readyState === WebSocket.OPEN) {
            this.sendRawMessage(messageData);
          } else {
            this.messageQueue.push(messageData);
            this.addSystemMessage('Message queued. Will send when connection is restored...');
            this.connect();
            throw new Error('WebSocket not ready');
          }
        } catch (error) {
          console.error('Error in queueOrSendMessage:', error);
          this.handleMessageError();
        }
      }
      
      // 3.2 Handle message sending errors
      handleMessageError() {
        this.addErrorMessage('Failed to send message');
        this.attemptReconnect();
      }
      
      // 3.3 Add a user message to the chat
      addUserMessage(message) {
        const messageElement = document.createElement('div');
        messageElement.className = 'message user';
        messageElement.innerHTML = `
          <div class="message-time">${this.getCurrentTime()}</div>
          <div class="message-content">${this.escapeHtml(message)}</div>
        `;
        this.chatMessages.appendChild(messageElement);
        this.scrollToBottom();
        
        // Show typing indicator after user sends a message
        this.showTypingIndicator();
      }


      // Add a system message to the chat
      addSystemMessage(content) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message system';
        messageDiv.innerHTML = `
          <div class="message-time">${this.getCurrentTime()}</div>
          <div class="message-content">${this.escapeHtml(content)}</div>
        `;
        this.chatMessages.appendChild(messageDiv);
        this.scrollToBottom();
      }

    
      // Add an error message to the chat
      addErrorMessage(content) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message error';
        messageDiv.innerHTML = `
          <div class="message-time">${this.getCurrentTime()}</div>
          <div class="message-content">Error: ${this.escapeHtml(content)}</div>
        `;
        this.chatMessages.appendChild(messageDiv);
        this.scrollToBottom();
      }
      
      // Update or add a bot message (for streaming)
      updateOrCreateBotMessage(content) {
        // Remove typing indicator if present
        this.removeTypingIndicator();
        
        // Create new message if needed
        if (!this.lastBotMessage) {
          this.lastBotMessage = document.createElement('div');
          this.lastBotMessage.className = 'message agent';
          this.lastBotMessage.innerHTML = `
            <div class="message-time">${this.getCurrentTime()}</div>
            <div class="message-content"></div>
          `;
          this.chatMessages.appendChild(this.lastBotMessage);
        }
        
        // Update message content
        const contentDiv = this.lastBotMessage.querySelector('.message-content');
        contentDiv.textContent = content;
        
        this.scrollToBottom();
      }
      
      // Mark the last bot message as complete
      markLastMessageComplete() {
        this.lastBotMessage = null;
        this.removeTypingIndicator();
      }
      
      // Show waiting for response indicator
      showTypingIndicator() {
        this.removeTypingIndicator();
        
        this.typingIndicator = document.createElement('div');
        this.typingIndicator.className = 'waiting-indicator';
        this.typingIndicator.textContent = 'AIDAR is thinking';
        this.chatContainer.appendChild(this.typingIndicator);
      }
      
      // Remove typing indicator
      removeTypingIndicator() {
        if (this.typingIndicator) {
          this.typingIndicator.remove();
          this.typingIndicator = null;
        }
      }
      
      // Helper: Get current time in HH:MM AM/PM format
      getCurrentTime() {
        return new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }
      
      // Helper: Scroll chat to bottom
      scrollToBottom() {
        if (this.chatMessages) {
          this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
        }
      }
      
      // Helper: Escape HTML to prevent XSS
      escapeHtml(unsafe) {
        if (!unsafe) return '';
        return String(unsafe)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }
      
      // Update model ID and reconnect if needed
      updateModelId(newModelId) {
        console.log('[WebSocketManager] ===== Starting model ID update =====');
        console.log('[WebSocketManager] Current model ID:', this.currentModelId, 'New model ID:', newModelId);
        console.log('[WebSocketManager] Current connection state - isConnected:', this.isConnected, 
                    'isConnecting:', this.isConnecting, 
                    'socket state:', this.socket ? this.socket.readyState : 'no socket');
        
        // Handle case where newModelId is null/undefined
        if (newModelId === null || newModelId === undefined) {
          console.log('[WebSocketManager] New model ID is null/undefined, using random ID');
          newModelId = ''; // Will trigger random ID generation
        }
        
        // Normalize for comparison (treat empty string and null the same)
        const currentModelId = this.currentModelId || '';
        const normalizedNewModelId = newModelId || '';
        
        if (normalizedNewModelId === currentModelId) {
          console.log('[WebSocketManager] Model ID unchanged, keeping existing connection');
          return;
        }
        
        console.log('[WebSocketManager] Updating model ID from', currentModelId, 'to', normalizedNewModelId);
        
        // Set updating flag to prevent duplicate reconnections
        this.isUpdatingModelId = true;
        console.log('[WebSocketManager] Set isUpdatingModelId to true');
        
        try {
          this.currentModelId = normalizedNewModelId;
          this.sessionId = 'user-' + (normalizedNewModelId || Math.random().toString(36).substr(2, 9));
          this.wsUrl = `ws://localhost:8000/ws/${this.sessionId}`;
          
          console.log('[WebSocketManager] New session ID:', this.sessionId);
          console.log('[WebSocketManager] New WebSocket URL:', this.wsUrl);
          
          // Close existing connection and reconnect with new model ID
          if (this.socket) {
            this.cleanupExistingSocket();
          }
          
          this.connect();
          
        } catch (error) {
          console.error('[WebSocketManager] Error updating model ID:', error);
          this.isUpdatingModelId = false;
          throw error;
        } finally {
          this.isUpdatingModelId = false;
        }
      }
    }

  // ---------------------------------------------------------------------
  // Initialize WebSocket manager
  function initializeWebSocketManager() {
    console.log('[WebSocketManager] Initializing WebSocket manager');
    
    // Only initialize once
    if (window.wsManager) {
      console.log('[WebSocketManager] WebSocket manager already initialized');
      return window.wsManager;
    }
    
    // Initialize WebSocket manager and expose it globally
    try {
      window.wsManager = new WebSocketManager();
      console.log('[WebSocketManager] WebSocket manager initialized and exposed as window.wsManager');
      
      // Set up event listeners
      const sendButton = document.getElementById('send-button');
      const chatInput = document.getElementById('chat-input');
      
      if (!sendButton || !chatInput) {
        console.error('[WebSocketManager] Critical Error: Could not find required DOM elements');
        return window.wsManager;
      }
      
      console.log('[WebSocketManager] Found required DOM elements');
      
      // Auto-resize textarea
      chatInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
        
        // Update send button state
        const hasText = this.value.trim() !== '';
        sendButton.disabled = !hasText;
        console.log(`[WebSocketManager] Input changed, hasText: ${hasText}`);
      });
      
      // Initial button state
      sendButton.disabled = true;
      
      // Handle window unload
      window.addEventListener('beforeunload', () => {
        console.log('[WebSocketManager] Window unloading, cleaning up WebSocket');
        if (window.wsManager && window.wsManager.socket) {
          window.wsManager.socket.close(1000, 'Window closing');
        }
      });      
      console.log('[WebSocketManager] WebSocket manager initialization complete');
      return window.wsManager;
      
    } catch (error) {
      console.error('[WebSocketManager] Failed to initialize WebSocket manager:', error);
      // Show error to user
      const errorMsg = document.createElement('div');
      errorMsg.style.position = 'fixed';
      errorMsg.style.bottom = '20px';
      errorMsg.style.right = '20px';
      errorMsg.style.backgroundColor = '#ff4444';
      errorMsg.style.color = 'white';
      errorMsg.style.padding = '10px 20px';
      errorMsg.style.borderRadius = '5px';
      errorMsg.style.zIndex = '1000';
      errorMsg.textContent = 'Failed to connect to AI Assistant. Please refresh the page.';
      document.body.appendChild(errorMsg);
      
      return null;
    }
  }
  
  // Initialize when DOM is loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeWebSocketManager);
  } else {
    initializeWebSocketManager();
  }


  // Notes Sidebar
  if(typeof sidebar === 'undefined') {
    const sidebar = document.getElementById('right-sidebar');
    const button = document.getElementById('sidebar-button');
    const mainContent = document.querySelector('.main-content-move');
    const content = document.querySelector('.main-content');
    const agentSidebar = document.getElementById('agent-sidebar');
    const agentButton = document.getElementById('agent-sidebar-button');

    function updateMargins() {
      const notesOpen = sidebar.classList.contains('open');
      const agentOpen = agentSidebar && agentSidebar.classList.contains('open');

      // Calculate total margin based on open sidebars
      let totalMargin = 0;
      if (notesOpen && agentOpen) {
        totalMargin = 800; // Both sidebars open
      } else if (notesOpen || agentOpen) {
        totalMargin = 400; // One sidebar open
      } // else 0, both closed

      // Apply the new margin with smooth transition
      if (mainContent) mainContent.style.marginRight = totalMargin + 'px';
      if (content) content.style.marginRight = totalMargin + 'px';

      // Update button positions
      if (button) button.style.right = (notesOpen ? totalMargin : 0) + 'px';
      if (agentButton) agentButton.style.right = (agentOpen ? totalMargin : 0) + 'px';
    }

    if (sidebar && button && content && mainContent) {
      button.addEventListener('click', function () {
        sidebar.classList.toggle('open');
        button.classList.toggle('open');
        updateMargins();
      });
    } else {
      console.error("Required elements not found");
    }
  }

  (function() {
    let displays = document.querySelectorAll('.note-display');
    const transitionDuration = 900;

    displays.forEach(display => {
      let note = parseFloat(display.dataset.note);
      let [int, dec] = display.dataset.note.split('.');
      [int, dec] = [Number(int), Number(dec)];

      strokeTransition(display, note);

      increaseNumber(display, int, 'int');
    });

    function increaseNumber(display, number, className) {
      let element = display.querySelector(`.percent__${className}`),
        decPoint = className === 'int' ? '%' : '',
        interval = 900 / number,
        counter = 0;

      let increaseInterval = setInterval(() => {
        if (counter === number) { window.clearInterval(increaseInterval); }

        element.textContent = counter + decPoint;
        counter++;
      }, interval);
    }

    function strokeTransition(display, note) {
      let progress = display.querySelector('.circle__progress--fill');
      let radius = progress.r.baseVal.value;
      let circumference = 2 * Math.PI * radius;
      let offset = circumference * (100 - note) / 100;

      progress.style.setProperty('--initialStroke', circumference);
      progress.style.setProperty('--transitionDuration', `${transitionDuration}ms`);

      setTimeout(() => progress.style.strokeDashoffset = offset, 1000);
    }
  })();


  // Agent Sidebar
  (function() {
    // Get all required elements
    const agentSidebar = document.getElementById('agent-sidebar');
    const agentButton = document.getElementById('agent-sidebar-button');
    const notesButton = document.getElementById('sidebar-button');
    const chatInput = document.getElementById('chat-input');
    const sendButton = document.getElementById('send-button');
    const chatMessages = document.getElementById('chat-messages');
    const sidebar = document.getElementById('right-sidebar');
    const mainContent = document.querySelector('.main-content-move');
    const content = document.querySelector('.main-content');

    // Check if all required elements exist
    if (!agentSidebar || !agentButton || !notesButton || !chatInput || !sendButton || !chatMessages) {
      console.warn('Agent sidebar elements not found');
      return;
    }

    /**
     * Update the margins of the main content based on sidebar states
     */
    function updateAgentMargins() {
      const agentOpen = agentSidebar.classList.contains('open');
      const notesOpen = sidebar && sidebar.classList.contains('open');

      // Calculate total margin based on open sidebars
      let totalMargin = 0;
      if (notesOpen && agentOpen) {
        totalMargin = 800; // Both sidebars open
      } else if (notesOpen || agentOpen) {
        totalMargin = 400; // One sidebar open
      } // else 0, both closed

      // Apply the new margin with smooth transition
      if (mainContent) mainContent.style.marginRight = totalMargin + 'px';
      if (content) content.style.marginRight = totalMargin + 'px';

      // Update button positions
      if (notesButton) notesButton.style.right = (notesOpen ? totalMargin : 0) + 'px';
      if (agentButton) agentButton.style.right = (agentOpen ? totalMargin : 0) + 'px';
    }

    // Position notes button below agent button
    function positionAgentButton() {
      const agentRect = agentButton.getBoundingClientRect();
      notesButton.style.top = `${agentRect.bottom + 20}px`;
    }

      // Initial positioning
    positionAgentButton();

    // Re-position on window resize
    window.addEventListener('resize', positionAgentButton);

    // Toggle sidebar
    agentButton.addEventListener('click', function() {
      agentSidebar.classList.toggle('open');
      agentButton.classList.toggle('open');
      updateAgentMargins();
    });

    // Also update margins when notes sidebar is toggled
    if (sidebar) {
      const observer = new MutationObserver(updateAgentMargins);
      observer.observe(sidebar, { attributes: true, attributeFilter: ['class'] });
    }

    // Auto-scroll to bottom of chat with smooth animation
    function scrollToBottom() {
      if (chatMessages) {
        chatMessages.scrollTo({
          top: chatMessages.scrollHeight,
          behavior: 'smooth'
        });
      }
    }

    // Initial scroll to bottom
    scrollToBottom();

    // Scroll to bottom when content changes
    if (chatMessages) {
      let isScrolling = false;
      const scrollObserver = new MutationObserver(() => {
        if (!isScrolling) {
          isScrolling = true;
          // Small delay to ensure DOM is updated
          requestAnimationFrame(() => {
            scrollToBottom();
            isScrolling = false;
          });
        }
      });

      // Observe chat messages for changes
      scrollObserver.observe(chatMessages, { childList: true, subtree: true });
    }

    // Format time
    function getCurrentTime() {
      const now = new Date();
      return now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    // Add a new message to the chat
    function addMessage(content, isUser) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${isUser ? 'user' : 'agent'}`;

      const timeDiv = document.createElement('div');
      timeDiv.className = 'message-time';
      timeDiv.textContent = getCurrentTime();

      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      contentDiv.textContent = content;

      messageDiv.appendChild(timeDiv);
      messageDiv.appendChild(contentDiv);
      chatMessages.appendChild(messageDiv);

      scrollToBottom();
    }

    // Safe function to get or initialize WebSocket manager
    function getWebSocketManager() {
      if (!window.wsManager) {
        console.log('[AgentSidebar] Initializing WebSocket manager from agent sidebar');
        initializeWebSocketManager();
      }
      return window.wsManager;
    }

    // Event listeners for the agent sidebar
    sendButton.addEventListener('click', (e) => {
      e.preventDefault();
      const message = chatInput.value.trim();
      if (message) {
        try {
          console.log('[AgentSidebar] Sending message via WebSocket manager');
          const manager = getWebSocketManager();
          if (manager) {
            manager.sendMessage();
          } else {
            console.error('[AgentSidebar] Failed to get WebSocket manager');
          }
        } catch (error) {
          console.error('[AgentSidebar] Error sending message:', error);
        }
      }
    });

    // Handle input changes
    function updateSendButtonState() {
      const hasText = chatInput.value.trim() !== '';
      sendButton.disabled = !hasText;
      sendButton.classList.toggle('has-text', hasText);
    }

    chatInput.addEventListener('input', updateSendButtonState);

    // Handle Enter key to send message
    chatInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        const message = chatInput.value.trim();
        if (message) {
          try {
            console.log('[AgentSidebar] Sending message via WebSocket manager (Enter key)');
            const manager = getWebSocketManager();
            if (manager) {
              manager.sendMessage();
            } else {
              console.error('[AgentSidebar] Failed to get WebSocket manager');
            }
          } catch (error) {
            console.error('[AgentSidebar] Error sending message:', error);
          }
        }
      }
    });

    // Initial states
    updateSendButtonState();
    setTimeout(scrollToBottom, 0);

    // Handle window resize to maintain scroll position
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(scrollToBottom, 100);
    });

    // Clean up on unload
    window.addEventListener('beforeunload', () => {
      if (scrollObserver) {
        scrollObserver.disconnect();
      }
      window.removeEventListener('resize', scrollToBottom);
    });
    
    // Initialize the agent sidebar
    updateAgentMargins();
    
    // Make updateAgentMargins available globally for other scripts
    window.updateAgentMargins = updateAgentMargins;
  })(); // End of agent sidebar IIFE
  
  // Initialize WebSocket manager when DOM is loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeWebSocketManager);
  } else {
    initializeWebSocketManager();
  }
</script>
